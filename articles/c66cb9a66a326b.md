---
title: "Google ColabでKaggleの機械学習"
emoji: "🙆"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: [Python, Google Colab]
published: true
---

# GoogleColabでKaggleの機械学習
GoogleColabを利用してKaggleの機械学習に挑戦する方法を解説します。

---

## 1 GoogleColabとは何か

Googleが2017年頃から提供するクラウド実行環境の一つがGoogleColabです。
色々なプログラムをブラウザ上から簡単に操作ができるシステムで、仮想環境をクラウドで提供します。
![](/images/Gemini_Generated_Image_qmpxu1qmpxu1qmpx.png)
プログラムを実行するための環境構築の負担を下げ、教育・研究・プロトタイピングを支援することを目的としています。GoogleのIDが在れば、だれでも無料で利用が可能です（高機能な有料版もあります）。

主な用途は、
- 小〜中規模の機械学習実験
- GPU/TPU を用いた短期の実験
- 教育・チュートリアルの配布や共有
- Kaggle の素早い検証・ベースライン実行

などです。

### サービスの基本的な仕組み
GoogleColabは**ジュピターノートブック**と呼ばれるファイルをブラウザ上で操作します。このファイルは基本的にGoogleDriveに保存され、ノートには以下の２つを含みます。

- 処理の実行できるコードブロック
- 文章の入るテキストブロック

これらを適宜、組み合わせて使用します。

### 仮想環境とは

GoogleColabはブラウザ越しで操作可能な仮想環境を提供します。仮想環境は「サーバにあるパソコンのレンタル」のようなものです。

- プログラムを動かすために必要な道具（Python やライブラリ）が最初から揃っています。
- 自分のパソコンに何かをインストールしなくてもすぐにプログラムを試せます。
- レンタルなので「長く使えない」「電源が切れると消える」などの制約があります。重要なファイルは GoogleDrive（またはGitHub） に保存します。

#### 電源OFFで消えてしまう
動作していた仮想環境は、電源OFFで記憶しているものは消えます。リセット状態になるのを防ぎたい場合は、保存したいデータをGoogleDriveに保存し、起動後にはそれを読み込む形にします。全てがやり直しになることに注意しましょう。実行時間があまりかからない処理の部分はそのままでも問題ないと思います。

### Linuxとは
GoogleColabの提供する仮想環境は、LinuxというOSが動きます。Linuxとは、OSの一種です。エンドユーザーが主に利用するOSの代表的なものは、Windows,iOS,Android,MacOSなどがあります。

![](/images/OSmap.png)

Linuxは主にサーバやIoTなどの特定のクライアントで動作します。
UI（操作に用いる方法）はシンプルな文字入力によるCUI（CharacterUserInterface）を用いています、マウス操作は要りません。それが便利なので、インターネットでのURLでサーバを操作するなども簡単にできています。Windowsのようなアイコンで操作するGUI（GraphicalUserInterface）をもたせることも可能です。

### 提供されるハードウエア環境
Linuxが動作するコンピュータとして提供されるハードウエア環境は、基本的には市販のコンピュータの延長線上ですが、利用者の多少によってつかえるリソースが変動します。使用量を払うと、GPUが使える環境が手に入ったり、環境が保証されるなどの違いがあります。

#### CPUとGPUの違い
GoogleColabで課金すると、GPUが使えるようになります。
![](/images/Gemini_Generated_Image_olklqkolklqkolkl.png)
GPU（Graphics processing unit）は、グラフィックス処理のために搭載される、小さな計算器を多数、集積したユニットです。PC内のグラフィックスは、３Dでは三次元の座標を何段階か変換し、画面の座標に置き換えます。座標の計算は離散的（それぞれで独立して計算する）なため、大量に個別で計算できる機構が求められます。他方、機械学習では、大量のデータから学習する際に離散的な計算を必要とするモデルがあります。特に大量に離散的にするニューラルネットは役に立ちます。他のモデルでもGPU向けにライブラリが在れば有効活用できます。

### 課金
課金することで、連続で利用できる時間がながくなったり、大容量メモリGPUが使えるなどが可能になります。詳しくはサイトで確認してください。

### KaggleとGoogleColabの違い
KaggleのWebでも、GoogleColabと同様に仮想環境が提供されますが、中身が違います。提供されるバージョンの違いやAIによるサジェストの有無などを較べるとGoogleColabの方が便利です。データ読み込みや提出が簡単というメリットはあります。
使い方がわかるならGoogleColabでKaggleのノートを動かすのは問題ないです。

---

## 2 Pythonこれだけ知っておく
LLMエージェントの趨勢で、AIを利用したバイブコーディングが加速しましたが、その前から、言語の仕様やライブラリの細部を知る必要が減少しています。細部の最適化には必要になりますが、最初の段階ではほぼ不要でしょう。また、学習コストが無駄に高くなる割に学習モデルの作成には効果的ではないので、理解すべき基礎をしっかり、おさえて挑めば問題ありません。

### importとインストールの違い
Pythonでプログラミングするときに、標準で出来る四則演算などはそのまま書けばいいですが、何か特別なことをしたいときには、ライブラリと呼ぶ道具をパッケージとして読み込み、利用します。多様に在るので、全部を標準装備は無駄になるので、どれを使うかを指定して呼び出します。

#### Pythonのシステムに備わっているものは `import`
Python内部にあるものは`import`で利用可能にします。
よくある例を以下に示します。
```python
import pandas as pd
import  numpy as np
import matplotlib.pyplot as plt
```

ここで、
```python
import □□□□□ as ◯◯
```
と記した場合、
> 「`□□□□□`をimportして〇〇として略して参照する」

という処理を実行します。

#### 外部から取り入れる必要がある場合`install`
Pythonから利用できる形で提供されている外部のライブラリを用いる場合、`install`を実行します。この場合、Pythonの命令ではなく、Linuxのコマンドを実行することになります。

##### コマンドを実行するふたつの書き方

###### セル全体がコマンドの場合`%%bash`
先頭行に`%%bash`があった場合、記述された内容を仮想環境のLinuxコマンドとして実行します。

```bash
%%bash
pip install japanize-matplotlib
kaggle competitions download -c m5-forecasting-accuracy --force
```
##### 一行コマンドの場合`！`を先頭につける
`！`がある行だけLinuxコマンドとして実行され、他はPythonで実行されます。

```python
!pip install japanize-matplotlib
import japanize_matplotlib
japanize_matplotlib.japanize()
```
尚、ここで使っている`pip`はPythonでのパッケージを管理するシステムです。ライブラリのパッケージには他のパッケージを利用するものがあり、併せてインストールすることなどの管理をしています。

### インデントとブロック
ソースコードの先頭に空白がある行は、そのまま無条件に実行されない行になります。このような、右に移動している形をインデントとよび、それの集合をブロックと呼びます。
Pythonでは、他の言語（C言語や、その系譜になるC++,Java,C#など）によく見受けられる波かっこ「`｛｝`」ではなくインデント（字下げ）でコードのブロックを表します。同じブロックは同じだけ字下げし、慣例的にスペース4つを使います。

以下は繰り返しの条件を設定して実行する`for`の例です。
```python
for train_idx, val_idx in kf.split(X_train, y_train):
    x_tr, y_tr = X_train.iloc[train_idx], y_train.iloc[train_idx]
    x_va, y_va = X_train.iloc[val_idx], y_train.iloc[val_idx]
    model = CatBoostClassifier(**params)
```
以下はPathsというclass宣言をして中身の定義をしています。
```python
class Paths:
    P = "/content/kaggle/"
    train = P + "train.csv"
    test = P + "test.csv"
    sample = P + "sample_submission.csv"
```
この例ではPathsというclass宣言をして中身の定義をしています。

### .と（）の意味
プログラムのコードに`.`が頻繁に出てきます。これは、
```py
□□□□□.◯◯
```
と記した場合、
> 「`□□□□□`に属する〇〇」

という意味になります。これがもっと繋がるときもあります。
また、`（）`は処理の依頼を意味するものです。処理によって結果が帰る場合は`=`で何かに代入します。
```python
aa = bbb.ccc.ddd(x,y,z)
```
と記した場合、
> 「`bbb`に属する`ccc`の中の`ddd`にの変数の`x,y,z`を渡して処理し、結果を`aa`に代入してください」

という内容になります。AIにヘルプさせると`.`を打つと候補がサジェストされます。`（）`が右辺の式にない場合、何かの変数から代入だけになります。

## 3 実践Tips
GoogleColabを利用する際、使えると便利な機能や、仮想環境を意識した利用方法のヒントを以下に示します。

### 見出しで区切る
ノートにはテキストブロックで色々、説明できますが、これはコードブロックにコメントで書くことも可能で、備忘録などを書くと無駄に長くなってしまい、どこで何をやっていたか分からなって時間を無駄にすることもあります。このとき、テキストブロックで見出しを作っておくと、とても便利です。見出し単位で折りたたみができます。
![](/images/SS_noteTitle.png)
こうしておくことで、もういじらなくて良い部分は隠して、長々とスクロールすることを防げます。

### 変更履歴の利用
Kaggleへ提出を繰り返す際に、以下の順番で行ったとします。

1. 初期状態で一度、Kaggleへ提出
2. データを見直してラベルAを追加して再度、提出
3. 改善が見られたのでまた別のラベルBを追加、提出
4. 更にパラメータチューンして提出
5. ラベルBは効果がないのでラベルAにパラメータチューンしたい

こうした場合、2の状態のノートと4の状態のノートを併せ、ラベルBの部分は除く、という編集が必要と判断すると、そこまで変更履歴を戻す（ロールバック）したいときに、ノートを編集すると何処で何を変更したか、わからない状態に陥ることがあります。また、Kaggleへ繰り返し提出していると、毎回、改善が見られることはないため、いつのノートが高スコアだったか、不明になることもあります。

こうした問題に対処するため、「版を固定して保存」することが有効です。
![](/images/ss_SaveTag.png)
これを用いると、その保存したバージョンに名前が残せます。別名で保存することで版を固定することも可能ですが、どこを編集したのか、差分を確認できるのが便利なところです。
![](/images/SS_CodeCompare.png)
これで変更箇所の確認もでき、場合によってはそのバージョンに簡単に遡って、無駄になった変更を破棄することも可能です。
こうしたことはGitなどのバージョン管理を利用したことが在るエンジニアの方はご存知でしょう。GoogleColabはGithubのリポジトリに接続することも可能なので、慣れてる方はそちらでバージョン管理することもできます。

更に、Kaggleへ提出したデータがログで判るようにすると、どのノートから出力したファイルが幾つのスコアだったのか分かりやすくなります。以下はファイル名にタイムスタンプを残す方法です。Submitにも時刻が残りますが表記がざっくり何日前とかで、実際に照合しにくいからです。

```python
from datetime import datetime

# 現在の日時を取得してフォーマット
timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")

# ファイル名に日付と時刻を追加
filename = f"submission_{timestamp}.csv"

# CSV を保存
submission_merged.to_csv(filename, index=False)

# Kaggle へ提出
!kaggle competitions submit -c m5-forecasting-accuracy -f {filename} -m "upload"
print(f"Submission saved as {filename}")
```
セルの出力は以下になります。

```セルの出力
100% 20.5M/20.5M [00:00<00:00, 54.9MB/s]
Successfully submitted to M5 Forecasting - AccuracySubmission saved as submission_20251019_080545.csv
```

KaggleのSubmitにメモが残せるので、それも有効活用しましょう。
![](/images/SS_KaggleScoreMemo.png)

頻繁にコードの修正と取り消しが発生します、面倒になって初めからやり直すのも可能ですが、新規チャットでやると途中でLLMに尋ねてると違う応答になり、再現できないこともあります。

### LLMに作らせる
LLMによるコーディングが一般化しているので、「今更、コードを地道に打つのは面倒」と思う人が大多数でしょう。そうした場合の利用方法です。

#### コーディングのお助け
GoogleColabでは設定していれば、簡単にコーディングをサジェストしてくれるので、活用しましょう。期待していないものが出来上がることもあるので、注意は必要です。
また、エラーが発生するとエラーを消すことを助けてくれますが、発生源を単純に削除するなど、直し方が雑な場合もあるので、やはり注意が必要です。
Colab内のGeminiに日本語入力したい場合、特に面倒なのが、**日本語変換でEnterキーを押すと送信される**という現象です。これは他で入力してコピペするなどが要りますが、とても不便です。全体を見直したい場合、他のタブでLLMを開いてノートを読み込ませ、指示するなどでやる方法も有効です。

#### エージェントにやらせる（やれる人向け）
ノートはブラウザ上で編集するので、もし利用できるエージェントがあるなら、代行で編集させることが可能です。ノートをDLしVScodeでCopilotのエージェントに編集させることもできます。SSHで接続なども在ると思いますが、適宜、方法を探してください。出来る人は実装できると思いますし、固定の方法をここで記すと追随の必要があるので、ここでは割愛します。

### メモリ不足・遅い処理への対処
学習するデータフレームが大きくなると、自ずと処理に時間がかかります。数分や数時間は未だマシで、日をまたぐこともありえます。また、大きくなりすぎてメモリ不足で実行できなくなることも頻繁になることもあります。
![](/images/SS_Crush.png)
そうした場合の対処方法です。

#### 仮想マシンの変更
課金のProを利用している場合、環境の変更が可能です。
![](/images/SS_RuntimeSetteing.png)
まず、ハイメモリ設定にしましょう。また、GPUが利用できるライブラリの場合は、以下を実行しましょう。

1. ハードウェアアクセラレータを指定、GPUを有効に
2. スクリプトでGPUを有効化

GPU内のVRAMにデータを移せる部分があれば、メモリ不足の解消と離散処理が高速化する可能性があります。

#### 無用なデータを消す

処理ごとに、そのときに必要なデータ以外は破棄すると、メモリに空きが増やせます。例えば、入力するデータの構築で用いたデータに個人名簿、カレンダー、個人の購買行動がそれぞれ独立したデータフレームに存在した場合、学習に使うのが合体したものであれば、他は明示的に消すことでメモリの空きが増やせます。

```python
# 例: マージ後に元の DataFrame を削除してメモリを解放する
import gc

# ここでは df_left, df_right をキー 'id' でマージして df に集約する例を示します。
# 実際のキーや how はデータ構造に合わせて変更してください。
df = df_left.merge(df_right, on='id', how='left')

# マージ後に元の参照を削除してガベージコレクションを促す
del df_left, df_right
gc.collect()

# 必要に応じて、明示的に不要列を削除してメモリ削減
# df.drop(columns=['tmp_col1','tmp_col2'], inplace=True)
```

自動的に使わないものを消去して空きを増やすガベージコレクションという機構がPythonには備わってますが、データの参照範囲（ブロック）が広くなりがちなノートでは有効に機能しにくい状況があるため、意図的に消去すると効果的なことがあります。

#### パラメータの変更
簡単に出来るのは、パラメータでのモデルの複雑さを減らすなどです。これは性能が下がる可能性もあり躊躇しますが、無駄に深い場合もあるので検討しましょう。ニューラルネットでは畳み込み方法にも関連します。

#### 学習データ量の検討
気持ち的には全部のデータを学習に用いたいところですが、そのためにメモリがパンクするようだと困ります。データの削減を試みます。

##### ラベルを減らす
これはモデルの改善と同じで考える部分で、従属関係のあるラベルやノイズになっているものを削減する方法です。やりすぎても性能が下がることはあるので、注意をはらいながら削減しましょう。

##### 行を減らす
元のデータの件数を減らす方法です。これもやり方が難しいですが、時系列なら昔のデータは使わない、など、影響度を考えて試しましょう。

##### データを分割する
特定のラベルごとにまとめたり、行を分けてまとめて小さなデータフレームに分割します。それぞれで学習するならば必要なメモリ量は減らせます。分割してできた複数モデルの平均などを用いる方法です。

##### データ・タイプの変更
数値の場合、必要なバイト数が異なります。できるだけ削減します。

以下は NumPy 型と bool の代表的な数値型一覧です。

| 型 | 小数・整数 | 範囲（目安） | バイト数（格納領域の目安） |
|---|---:|---|---:|
| numpy.int8 | 整数 | -128 〜 127 | 1 |
| numpy.int16 | 整数 | -32,768 〜 32,767 | 2 |
| numpy.int32 | 整数 | -2,147,483,648 〜 2,147,483,647 | 4 |
| numpy.int64 | 整数 | 約 -9.22e18 〜 9.22e18（約 ±2^63） | 8 |
| numpy.float32 | 小数（単精度） | 約 ±3.4×10^38 | 4 |
| numpy.float64 | 小数（倍精度） | 約 ±1.8×10^308 | 8 |
| bool / numpy.bool_ | 真偽（論理値） | True / False | 1（概念上） |

注記:
- 上の「バイト数」は各値を格納するデータ幅の目安です。NumPy 配列は同じ型を連続で並べるため、Python の組み込み `list` や CPython オブジェクトに比べメモリ効率が良くなります。
- 金額など誤差を許さない小数計算には `decimal.Decimal` を検討してください（ただし NumPy の浮動小数点と比べて計算は遅く、別途扱いが必要です）。

変更する場合は以下で考えて試しましょう。

- 整数で良いものは整数にする
- 値の範囲が小さいものはバイト数が少ないものに寄せる

さらに、値によっては標準化や対数にしたら少なく出来る場合もあるので、検討します。
究極的には数値の組み合わせによって1ビットに意味をもたせる方法（ワンホットベクトルをビット単位にするなど）もありますが、読み込みで1ビット単位にならないのでユニークなデータとして扱われても期待通りにならないことがあります、やり過ぎには注意が必要です。


#### 段階的な学習
部分ごとに分けて学習するインクリメンタル学習やアンサンブルを用い、読み込むデータやモデルのサイズを減らします。以下はインクリメンタルの例。
`batch_size=1000`の部分が分割単位です。

```python
# 例: Scikit-learnでの部分的な学習
from sklearn.linear_model import SGDClassifier
import numpy as np

model = SGDClassifier(loss='log_loss')
classes = np.unique(y_all) # すべてのクラスを事前に指定する必要がある

# データ生成（実際には大きなデータセットからバッチを読み込む）
data_batches = generate_data_in_batches(X_all, y_all, batch_size=1000)

for X_batch, y_batch in data_batches:
    model.partial_fit(X_batch, y_batch, classes=classes)

# 最終的に 'model' がすべてのバッチから学習した単一のモデルとなります。

```
インクリメンタルでやるときとまとめてフルバッチ学習する場合では、差ができることがあるので注意が必要です。離散的に処理が可能なニューラルネットでは差分が出にくいですが、勾配法の場合は個別で動作するモデルに近い状況になります。

### 稼働時間が長い
データ量を削減すれば概ね完了までの時間は短縮しますが、永らく待たされて結果がなかなか出ないことがあります。

#### 自分のPCとColabを繋ぐ
いつまでもずっと動かしたい場合、自分のPCにDockerで仮想環境を構築し、GoogleColabから接続する方法です。この場合、ノートを自分でローカル環境で動かしても良い、ということにはなるので、あまり意味は無いかも知れませんが、GoogleColabより強力で安定的に使えるPCをローカル持っているなら有益です。
やる方法は適宜、調べてください。

#### オススメしないがお金で解決
お金を払うとリソースを得られる方法が増えます。

#### 重課金
Pro+にするとブラウザを閉じても実行を続けます。GPUの性能や保証も変わります。

#### 他のCloud
仮想環境を他のものにすれば更に高性能化は可能です。

#### お金で解決することは技術がいらない
一応、提示はしましたが、高性能な環境で動作するのは当たり前で、工夫も要りません。低性能の環境で動作することで、中身を精査することが求められ、それがモデルの性能を上げることもあります。

---

## 5 😩とにかくわけがわからない😩
色々やってて混乱し、何がなんだかわからないまま暗中模索から脱しない、そういう場合は以下を参考にしてください。

### LLMはあてになる
知見はかなりあります、バグの在るコードを吐くことはありかすが、使い方次第です。特に、サンプルでわからないところとか、書き出したコードの意味が分からない場合は、

- コードの内容が分かるようにコメントを一行ごとに追加
- 関連するPython,統計、数学の内容を細かく解説
- 中学生でも分かるように説明

などを指定して活用しましょう。

### データは残して質問
「きょうやったら何故かだめでした、うまくいくときもあります」などの再現性のないものは調べるのが大変に困難です。もし、LLMも含めて誰かに調べてほしい場合、問題のあったノートは遺しましょう。

### 基本は教材にアリ
基本的に他の教材で知りうる知見は役に立ちますので、一度、やった内容でも繰り返すと変わることがあります。特にPythonコードをただ実行ボタンを押すだけでわかった気分になっても、さきで躓きます。

### 追加で勉強すると解りやすくなるもの
教師あり学習はそのままのコードを眺めるだけでは分かり辛い部分もあります。説明させて出てきた単語がわからずその説明を求める繰り返しはよくあることです。抜本的に学習するなら、以下があると良いでしょう。

#### Pythonの基礎
備わっている教材でも理解できれば十分ですが、簡単な基礎本でやるのも良いです。

#### 確率・統計
どのラベルをどうしたら良いかなどで標準化などをする際に知識としてあると便利です。理系の大学を出てる方は履修歴が在る方も居ると思います。分散や標準偏差などは高校の数学でやってるはずです。評価関数のRMSEが何なのかなども理解しやすくなります。

#### 線形代数
データフレームを行列に見立てて捉えた場合に有効です、ベクトルと空間の概念はわかってても損はないですが、知ってるとどんどん高性能のモデルができる、というほどではありません。大学を出てる方なら、当時の教科書等が役立つ部分があると思います。

#### Kaggleの解説本
統合的に紹介から改善方法の解説が中心です、コードサンプルや実際の事例があると役に立ちます。実際に2冊、購入して読んでましたが、ここまで書いた内容と似通っていました。細かいパラメータチューンなどのコードの部分などは違いがあるものの、本を見ないで色々調べながらやっても王道の方法論は同じようです。

---

## 6 まとめ：基本は地道にやるしかない
機械学習を機械にさせるから簡単というものでもなく、最適化し高スコアを目指すのは地道なものです。入賞者の記事を読んでみると、意外と複雑なことは最終的にはやっていない状態ですが、そこに至るまでのパラメータなどの細部の調整が多い印象です。
一朝一夕にはいかない前提で、少しづつ理解しながら進めることをお勧めします。
